import * as Crypto from 'expo-crypto';

/**
 * Generate TOTP code based on RFC 6238
 */
export async function generateTOTP(
  secret: string,
  timeStep: number = 30,
  digits: number = 6
): Promise<string> {
  const epoch = Math.floor(Date.now() / 1000);
  const counter = Math.floor(epoch / timeStep);
  
  // Convert base32 secret to bytes
  const secretBytes = base32ToBytes(secret.replace(/\s/g, '').toUpperCase());
  
  // Convert counter to 8-byte array (big-endian)
  const counterBytes = new Uint8Array(8);
  let counterValue = counter;
  for (let i = 7; i >= 0; i--) {
    counterBytes[i] = counterValue & 0xff;
    counterValue = Math.floor(counterValue / 256);
  }
  
  // HMAC-SHA1
  const hmac = await hmacSha1(secretBytes, counterBytes);
  
  // Dynamic truncation per RFC 6238
  const offset = hmac[hmac.length - 1] & 0x0f;
  const binary =
    ((hmac[offset] & 0x7f) << 24) |
    ((hmac[offset + 1] & 0xff) << 16) |
    ((hmac[offset + 2] & 0xff) << 8) |
    (hmac[offset + 3] & 0xff);
  
  const otp = binary % Math.pow(10, digits);
  return otp.toString().padStart(digits, '0');
}

/**
 * Get remaining seconds until next TOTP refresh
 */
export function getRemainingSeconds(timeStep: number = 30): number {
  const epoch = Math.floor(Date.now() / 1000);
  return timeStep - (epoch % timeStep);
}

/**
 * Convert base32 string to Uint8Array
 * Strictly follows RFC 4648 Base32 encoding
 */
function base32ToBytes(base32: string): Uint8Array {
  const alphabet = 'ABCDEFGHIJKLMNOPQRSTUVWXYZ234567';
  
  // Remove padding and whitespace
  const cleanedBase32 = base32.replace(/=+$/, '').replace(/\s/g, '').toUpperCase();
  
  const bytes: number[] = [];
  let bits = 0;
  let value = 0;

  for (let i = 0; i < cleanedBase32.length; i++) {
    const char = cleanedBase32[i];
    const idx = alphabet.indexOf(char);
    
    if (idx === -1) {
      throw new Error(`Invalid base32 character: ${char}`);
    }

    value = (value << 5) | idx;
    bits += 5;

    if (bits >= 8) {
      bytes.push((value >>> (bits - 8)) & 0xff);
      bits -= 8;
    }
  }

  return new Uint8Array(bytes);
}

/**
 * HMAC-SHA1 implementation using expo-crypto
 * Strictly follows RFC 2104 for HMAC
 */
async function hmacSha1(key: Uint8Array, message: Uint8Array): Promise<Uint8Array> {
  const blockSize = 64;
  let keyBlock = new Uint8Array(blockSize);

  // If key is longer than block size, hash it first
  if (key.length > blockSize) {
    const keyHex = arrayToHex(key);
    const hash = await Crypto.digestStringAsync(
      Crypto.CryptoDigestAlgorithm.SHA1,
      keyHex,
      { encoding: Crypto.CryptoEncoding.HEX }
    );
    const hashBytes = hexToArray(hash);
    keyBlock.set(hashBytes);
  } else {
    // Otherwise, pad with zeros
    keyBlock.set(key);
  }

  // Create inner and outer padded keys
  const oKeyPad = new Uint8Array(blockSize);
  const iKeyPad = new Uint8Array(blockSize);

  for (let i = 0; i < blockSize; i++) {
    oKeyPad[i] = keyBlock[i] ^ 0x5c;
    iKeyPad[i] = keyBlock[i] ^ 0x36;
  }

  // Compute inner hash: H(K ⊕ ipad || message)
  const innerData = new Uint8Array(blockSize + message.length);
  innerData.set(iKeyPad);
  innerData.set(message, blockSize);

  const innerHashHex = await Crypto.digestStringAsync(
    Crypto.CryptoDigestAlgorithm.SHA1,
    arrayToHex(innerData),
    { encoding: Crypto.CryptoEncoding.HEX }
  );

  const innerHashBytes = hexToArray(innerHashHex);

  // Compute outer hash: H(K ⊕ opad || H(K ⊕ ipad || message))
  const outerData = new Uint8Array(blockSize + innerHashBytes.length);
  outerData.set(oKeyPad);
  outerData.set(innerHashBytes, blockSize);

  const outerHashHex = await Crypto.digestStringAsync(
    Crypto.CryptoDigestAlgorithm.SHA1,
    arrayToHex(outerData),
    { encoding: Crypto.CryptoEncoding.HEX }
  );

  return hexToArray(outerHashHex);
}

/**
 * Convert Uint8Array to hex string
 */
function arrayToHex(arr: Uint8Array): string {
  return Array.from(arr)
    .map((b) => b.toString(16).padStart(2, '0'))
    .join('');
}

/**
 * Convert hex string to Uint8Array
 */
function hexToArray(hex: string): Uint8Array {
  const bytes = [];
  for (let i = 0; i < hex.length; i += 2) {
    bytes.push(parseInt(hex.substr(i, 2), 16));
  }
  return new Uint8Array(bytes);
}

/**
 * Generate random base32 secret
 */
export function generateSecret(length: number = 32): string {
  const alphabet = 'ABCDEFGHIJKLMNOPQRSTUVWXYZ234567';
  let secret = '';
  const randomBytes = new Uint8Array(length);
  
  for (let i = 0; i < length; i++) {
    randomBytes[i] = Math.floor(Math.random() * 256);
    secret += alphabet[randomBytes[i] % alphabet.length];
  }
  
  return secret;
}

/**
 * Parse TOTP URI (otpauth://totp/...)
 */
export function parseTOTPUri(uri: string): {
  issuer: string;
  account: string;
  secret: string;
  digits?: number;
  period?: number;
} | null {
  try {
    const url = new URL(uri);
    
    if (url.protocol !== 'otpauth:' || url.hostname !== 'totp') {
      return null;
    }
    
    const path = decodeURIComponent(url.pathname.substring(1));
    const params = new URLSearchParams(url.search);
    
    const secret = params.get('secret');
    if (!secret) return null;
    
    let issuer = params.get('issuer') || '';
    let account = path;
    
    // Handle format: issuer:account
    if (path.includes(':')) {
      const parts = path.split(':');
      issuer = parts[0];
      account = parts.slice(1).join(':'); // Handle account names with colons
    }
    
    const digits = params.get('digits') ? parseInt(params.get('digits')!) : 6;
    const period = params.get('period') ? parseInt(params.get('period')!) : 30;
    
    return {
      issuer,
      account,
      secret: secret.replace(/\s/g, '').toUpperCase(),
      digits: digits,
      period: period,
    };
  } catch (error) {
    console.error('Error parsing TOTP URI:', error);
    return null;
  }
}

/**
 * Generate TOTP URI for QR code generation
 */
export function generateTOTPUri(
  account: string,
  secret: string,
  issuer?: string
): string {
  const label = issuer ? `${issuer}:${account}` : account;
  let uri = `otpauth://totp/${encodeURIComponent(label)}?secret=${secret}`;
  
  if (issuer) {
    uri += `&issuer=${encodeURIComponent(issuer)}`;
  }
  
  return uri;
}
